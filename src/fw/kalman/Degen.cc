// Copyright 2021 by Daniel Winkelman. All rights reserved.
// This file is autogenerated by kalman.py.

#include "Degen.h"

namespace Clef::Fw::Kalman {
namespace {
ARRAY(float, memQ, {/* xs */ 0.6643913126888928, /* dxsdt */ 0.15709419193317814, /* Ph */ 0.8749943848809725, /* Ph0 */ 0.10558164266330698, /* Ps */ 0.09164746424144346, /* a1 */ 0.2350069617854511, /* a0 */ 10.051952236083185, /* Chl */ 0.020650460931544275, /* gamma */ 0.0012055487723313366});
ARRAY(float, memR, {/* xs_in */ 5, /* Ph_in */ 1.910747935940628});
ARRAY(float, memWx, {/* xs */ 0.08564907165804703, /* dxsdt */ 0.9679720676046717, /* Ph */ 0.761561536487039, /* Ph0 */ 1, /* Ps */ 0.2903404040638757, /* a1 */ 0.20121356269619844, /* a0 */ 0.09910003513065686, /* Chl */ 0.026411231117992318, /* gamma */ 0.018612792192690863});
typename BaseDegenFilter::QMatrix Q(memQ);
typename BaseDegenFilter::RMatrix R(memR);
typename BaseDegenFilter::WxMatrix Wx(memWx);
} // namespace

DegenFilter::DegenFilter() : BaseDegenFilter(Q, R, Wx) { init(); }

void DegenFilter::evolve(
    /* Control Variables */ const float xe,
    /* Observation Variables */ const float xs_in, const float Ph_in,
    /* Time Step */ const float deltat) {
  float uMem[1];
  typename BaseDegenFilter::UVector u(uMem);
  u.set(0, 0, xe);
  float zMem[2];
  typename BaseDegenFilter::ZVector z(zMem);
  z.set(0, 0, xs_in);
  z.set(1, 0, Ph_in);
  BaseDegenFilter::evolve(u, z, deltat);
}

void DegenFilter::init() {
  P_.fill(0);
  x_.set(0, 0, 0);  // xs
  x_.set(1, 0, 0);  // dxsdt
  x_.set(2, 0, 0);  // Ph
  x_.set(3, 0, 4903.592289799023);  // Ph0
  x_.set(4, 0, 0);  // Ps
  x_.set(5, 0, 2.058031151135649);  // a1
  x_.set(6, 0, 0);  // a0
  x_.set(7, 0, 10.147701815528546);  // Chl
  x_.set(8, 0, 0.0823852983375337);  // gamma
  P_.set(0, 0, 5.968012553968996);  // xs
  P_.set(1, 1, 20.40001728557575);  // dxsdt
  P_.set(2, 2, 9.377230028352413);  // Ph
  P_.set(3, 3, 105.10288025005443);  // Ph0
  P_.set(4, 4, 10.814128153323214);  // Ps
  P_.set(5, 5, 1.0573914114763654);  // a1
  P_.set(6, 6, 100.36085314595985);  // a0
  P_.set(7, 7, 0.16893414298306883);  // Chl
  P_.set(8, 8, 0.049319423047475844);  // gamma
}

void DegenFilter::calculateStateTrans(
    const typename BaseDegenFilter::XVector &xk,
    const typename BaseDegenFilter::UVector &uk,
    const float deltat,
    typename BaseDegenFilter::XVector &output) const {
  // xs(k+1) = xs(k) + dxsdt(k) * deltat(k)
  output.set(0, 0, xk.get(0, 0) + xk.get(1, 0) * deltat);

  // dxsdt(k+1) = gamma(k) * Ps(k)
  output.set(1, 0, xk.get(8, 0) * xk.get(4, 0));

  // Ph(k+1) = Chl(k) * (xe(k) + -1 * xs(k))
  output.set(2, 0, xk.get(7, 0) * (uk.get(0, 0) + -1 * xk.get(0, 0)));

  // Ph0(k+1) = Ph0(k)
  output.set(3, 0, xk.get(3, 0));

  // Ps(k+1) = Ph(k) + -1 * a0(k) + -1 * a1(k) * dxsdt(k)
  output.set(4, 0, xk.get(2, 0) + -1 * xk.get(6, 0) + -1 * xk.get(5, 0) * xk.get(1, 0));

  // a1(k+1) = a1(k)
  output.set(5, 0, xk.get(5, 0));

  // a0(k+1) = a0(k)
  output.set(6, 0, xk.get(6, 0));

  // Chl(k+1) = Chl(k)
  output.set(7, 0, xk.get(7, 0));

  // gamma(k+1) = gamma(k)
  output.set(8, 0, xk.get(8, 0));
}

void DegenFilter::calculateStateTransGradient(
    const typename BaseDegenFilter::XVector &xk,
    const typename BaseDegenFilter::UVector &uk,
    const float deltat,
    typename BaseDegenFilter::FMatrix &output) const {
  output.fill(0);

  // dxs/dxs(k+1) = 1
  output.set(0, 0, 1);

  // dxs/ddxsdt(k+1) = deltat(k)
  output.set(0, 1, deltat);

  // ddxsdt/dPs(k+1) = gamma(k)
  output.set(1, 4, xk.get(8, 0));

  // ddxsdt/dgamma(k+1) = Ps(k)
  output.set(1, 8, xk.get(4, 0));

  // dPh/dxs(k+1) = -1 * Chl(k)
  output.set(2, 0, -1 * xk.get(7, 0));

  // dPh/dChl(k+1) = xe(k) + -1 * xs(k)
  output.set(2, 7, uk.get(0, 0) + -1 * xk.get(0, 0));

  // dPh0/dPh0(k+1) = 1
  output.set(3, 3, 1);

  // dPs/ddxsdt(k+1) = a1(k) * -1
  output.set(4, 1, xk.get(5, 0) * -1);

  // dPs/dPh(k+1) = 1
  output.set(4, 2, 1);

  // dPs/da1(k+1) = dxsdt(k) * -1
  output.set(4, 5, xk.get(1, 0) * -1);

  // dPs/da0(k+1) = -1
  output.set(4, 6, -1);

  // da1/da1(k+1) = 1
  output.set(5, 5, 1);

  // da0/da0(k+1) = 1
  output.set(6, 6, 1);

  // dChl/dChl(k+1) = 1
  output.set(7, 7, 1);

  // dgamma/dgamma(k+1) = 1
  output.set(8, 8, 1);
}

void DegenFilter::calculateObservationTrans(
    const typename BaseDegenFilter::XVector &xk,
    typename BaseDegenFilter::ZVector &output) const {
  // xs_in(k) = xs(k)
  output.set(0, 0, xk.get(0, 0));

  // Ph_in(k) = Ph(k) + Ph0(k)
  output.set(1, 0, xk.get(2, 0) + xk.get(3, 0));
}

void DegenFilter::calculateObserationTransGradient(
    const typename BaseDegenFilter::XVector &xk,
    typename BaseDegenFilter::HMatrix &output) const {
  output.fill(0);

  // dxs_in/dxs(k) = 1
  output.set(0, 0, 1);

  // dPh_in/dPh(k) = 1
  output.set(1, 2, 1);

  // dPh_in/dPh0(k) = 1
  output.set(1, 3, 1);
}
} // namespace Clef::Fw::Kalman
